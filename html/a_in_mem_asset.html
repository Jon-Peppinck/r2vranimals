<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: a_in_mem_asset()</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for a_in_mem_asset {r2vr}"><tr><td>a_in_mem_asset {r2vr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>a_in_mem_asset()</h2>

<h3>Description</h3>

<p>Create an A-Frame asset hosted in R's memory.
</p>


<h3>Usage</h3>

<pre>
a_in_mem_asset(.data, src, .parts = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>.data</code></td>
<td>
<p>a string containing file content or a list of such strings.</p>
</td></tr>
<tr valign="top"><td><code>src</code></td>
<td>
<p>a realistic path to a notional file. The path is used to set the
route the used by the scene server for the in memory asset. The file
extension of the is used to set the HTTP content header mime type.</p>
</td></tr>
<tr valign="top"><td><code>.parts</code></td>
<td>
<p>additional notional files referenced in the content of 'data'.
Unlike 'src' the names used here matter, e.g. if the 'src' file is a model
that references textures, those textures need to be mapped by relative
path inside 'src' the paths provided for 'parts' must be compatible with
these. When 'data' is a list, elements after the first are assumed to be
the in-memory content of 'parts', matched by list position.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>additional parameters passed to 'a_asset()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To understand this object you will almost certainly need to familiarise yourself with its base class 'A_Asset' first. See <code><a href="a_asset.html">a_asset</a></code>.
</p>
<p>This function is used to create a special kind of A-Frame asset that is only
notionally backed by a file. The primary use of this is for passing CRAN's
vignette checks, testing, and demonstration. From the end-user's perspective
an in-memory-asset appears exactly like a regular asset file. However the
scene creates a route to 'src' and 'parts' that reference the contents of
'data' rather than files specified by the paths in 'src' and 'parts'.
</p>
<p>An example usecase: Serving a JSON transform of an built-in R dataframe as an
asset without writing an intermediate JSON file to disk.
</p>
<p>It is still necessary to supply a 'real looking' path to the asset. The path must be
relative to the current R working directory, but other than that is doesn't
matter what it is. The most important aspect of this notional path is the
file extension, since this is used to determine the HTTP mime-type header
when the asset is served.
</p>
<p>'data' is either a length one character vector or a list of length one
character vectors. It must have the same length as the number of paths
supplied in 'src' + 'parts'. The character vectors are strings that contain
the entire contents of a notional file. For non-text files they would need
to contain the equivalent encoded text of calling readr::read_file_raw().
</p>


<h3>Value</h3>

<p>an asset object.
</p>

<hr /><div style="text-align: center;">[Package <em>r2vr</em> version 0.0.0.9000 <a href="00Index.html">Index</a>]</div>
</body></html>
